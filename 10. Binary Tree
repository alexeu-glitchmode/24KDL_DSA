//Practice 2
#include <stdio.h>
#include <stdlib.h>

typedef struct NodeType {
    int data;
    struct NodeType* left, * right;
} TreeNode;

typedef struct BinaryTreeType {
    struct NodeType* root;
} BinaryTree;

// Create a new node in memory
TreeNode* makeNode(int data) {
    TreeNode* newNode = (TreeNode*)malloc(sizeof(TreeNode));
    if (newNode == NULL) return NULL;
    newNode->data = data;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

// Initialize the tree to be empty
void init(BinaryTree* tree) {
    tree->root = NULL;
}

// Recursive helper for insertion
TreeNode* insertNode(TreeNode* node, int data) {
    if (node == NULL) {
        return makeNode(data);
    }
    if (data < node->data) {
        node->left = insertNode(node->left, data);
    } else if (data > node->data) {
        node->right = insertNode(node->right, data);
    }
    return node;
}

// Wrapper function to insert into the BinaryTree structure
void insert(BinaryTree* tree, int data) {
    tree->root = insertNode(tree->root, data);
}

// Standard In-order traversal (Left - Root - Right)
void print(TreeNode* node) {
    if (node != NULL) {
        print(node->left);
        printf("%d ", node->data);
        print(node->right);
    }
}

int main() {
    BinaryTree tree;
    init(&tree);

    // Sequence 1.1.1: 4, 6, 2, 3, 5, 1, 7
    int data[] = {4, 6, 2, 3, 5, 1, 7};
    int n = sizeof(data) / sizeof(data[0]);

    for (int i = 0; i < n; i++) {
        insert(&tree, data[i]);
    }

    printf("BST In-order Output (Question 1.2): \n");
    print(tree.root);
    printf("\n");

    return 0;
    
}

int searchValues[] = {40, 52, 100, 24};
for(int i = 0; i < 4; i++) {
    TreeNode* result = search(tree.root, searchValues[i]);
    if(result != NULL) {
        printf("Tim thay %d tai dia chi %p\n", result->data, (void*)result);
    } else {
        printf("Khong tim thay %d (NULL)\n", searchValues[i]);
    }
}


//Bài 1
#include <stdio.h>
#include <stdlib.h>

typedef struct Node {
    int data;
    struct Node* left;
    struct Node* right;
} Node;

Node* makeNode(int data) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->data = data;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

void insertTree(Node* root) {
    if(root == NULL) return;
    printf("%d ", root->data);
    insertTree(root->left);
    insertTree(root->right);
}


int main() {
     // Cây 1.1
    
    Node* root1 = makeNode(1);
    root1->left = makeNode(2);
    root1->right = makeNode(3);
    root1->left->left = makeNode(4);
    root1->left->right = makeNode(5);
    root1->right->left = makeNode(6);
    root1->right->right = makeNode(7);
    root1->left->left->left = makeNode(8);
    root1->left->left->right = makeNode(9);
    root1->left->right->left = makeNode(10);
    root1->left->right->right = makeNode(11);
    root1->right->left->left = makeNode(12);
    root1->right->left->right = makeNode(13);
    root1->right->right->left = makeNode(14);
    root1->right->right->right = makeNode(15);

    printf("Cay 1.1: ");
    insertTree(root1);
    printf("\n");
    
    // Cây 1.2 
    Node* root2 = makeNode(50);
    root2->left = makeNode(17);
    root2->right = makeNode(76);

    root2->left->left = makeNode(9);
    root2->left->right = makeNode(23);
    root2->right->left = makeNode(54);
    root2->right->right = makeNode(72);

    root2->left->left->right = makeNode(14);
    root2->left->right->right = makeNode(19);
    root2->right->right->left = makeNode(67);

    root2->left->left->right->left = makeNode(12);

    printf("Cay 1.2: ");
    insertTree(root2);
    printf("\n");
    
    // Cây 1.3
    Node* root3 = makeNode(15);
    root3->left = makeNode(11);
    root3->right = makeNode(26);
    root3->left->left = makeNode(8);
    root3->left->right = makeNode(12);
    root3->right->left = makeNode(20);
    root3->right->right = makeNode(30);
    root3->left->left->left = makeNode(6);
    root3->left->left->right = makeNode(9);
    root3->left->right->right = makeNode(14);
    root3->right->right->right = makeNode(35);

    printf("Cay 1.3: ");
    insertTree(root3);
    printf("\n");

    // Cây 1.4
    Node* root4 = makeNode(3);
    root4->left = makeNode(1);
    root4->right = makeNode(10);
    root4->left->left = makeNode(13);
    root4->left->right = makeNode(5);
    root4->left->left->left = makeNode(6);
    root4->right->left = makeNode(11);
    root4->right->right = makeNode(16);
    root4->right->right->left = makeNode(15);
    root4->right->right->right = makeNode(2);
    root4->right->right->left->left = makeNode(9);
    root4->right->right->left->right = makeNode(4);

    printf("Cay 1.4: ");
    insertTree(root4);
    
   
    return 0;
}


// Bài 2
#include <stdio.h>
#include <stdlib.h>

typedef struct NodeType {
    int data;
    struct NodeType *left, *right;
} TreeNode;

typedef struct BinaryTreeType {
    TreeNode *root;
} BinaryTree;

TreeNode* makeNode(int data) {
    TreeNode *node = (TreeNode*)malloc(sizeof(TreeNode));
    node->data = data;
    node->left = NULL;
    node->right = NULL;
    return node;
}

// Tìm nút có giá trị x
TreeNode* search(TreeNode* root, int x) {
    if(root == NULL) return NULL;
    if(root->data == x) return root;
    if(x < root->data) return search(root->left, x);
    else return search(root->right, x);
}

// Tìm node nhỏ nhất 
TreeNode* findMin(TreeNode* root) {
    while(root->left != NULL) root = root->left;
    return root;
}

// Xóa nút có giá trị x
TreeNode* deleteNode(TreeNode* root, int x) {
    if(root == NULL) return NULL;
    if(x < root->data) root->left = deleteNode(root->left, x);
    else if(x > root->data) root->right = deleteNode(root->right, x);
    else {
        if(root->left == NULL) {
            TreeNode* temp = root->right;
            free(root);
            return temp;
        } else if(root->right == NULL) {
            TreeNode* temp = root->left;
            free(root);
            return temp;
        } else {
            TreeNode* temp = findMin(root->right);
            root->data = temp->data;
            root->right = deleteNode(root->right, temp->data);
        }
    }
    return root;
}

// Chèn nút có giá trị x
TreeNode* insertNode(TreeNode* root, int x) {
    if(root == NULL) return makeNode(x);
    if(x < root->data) root->left = insertNode(root->left, x);
    else if(x > root->data) root->right = insertNode(root->right, x);
    return root;
}

// In các nút ở level k
void printLevel(TreeNode* root, int level) {
    if(root == NULL) return;
    if(level == 1) {
        printf("%d ", root->data);
    } else {
        printLevel(root->left, level-1);
        printLevel(root->right, level-1);
    }
}

// Inorder để kiểm tra
void inorder(TreeNode* root) {
    if(root == NULL) return;
    inorder(root->left);
    printf("%d ", root->data);
    inorder(root->right);
}

// Hàm gộp 4 yêu cầu
void processTree(BinaryTree* tree) {
    // 1. Tìm nút có giá trị 25
    TreeNode* found = search(tree->root, 25);
    if(found) printf("Tim thay nut co gia tri 25\n");
    else printf("Khong tim thay nut co gia tri 25\n");

    // 2. Xoá nút có giá trị 12
    tree->root = deleteNode(tree->root, 12);
    printf("Sau khi xoa 12: ");
    inorder(tree->root);
    printf("\n");

    // 3. Chèn nút có giá trị 23
    tree->root = insertNode(tree->root, 23);
    printf("Sau khi chen 23 (Inorder): ");
    inorder(tree->root);
    printf("\n");

    // 4. In ra level 3
    printf("Level 3 gom cac nut: ");
    printLevel(tree->root, 3);
    printf("\n");
}

int main() {
    BinaryTree tree1, tree2, tree3, tree4;
    tree1.root = NULL;
    tree2.root = NULL;
    tree3.root = NULL;
    tree4.root = NULL;
   
    // Cây 1.1
    int a1[] = {1, 2 ,4, 8, 9 ,5 ,10 ,11, 3 ,6 ,12, 13, 7, 14, 15};
    int n1 = sizeof(a1)/sizeof(a1[0]);;
    for(int i=0;i<n1;i++) {
        tree1.root = insertNode(tree1.root, a1[i]);
    }

    printf("\nCay 1.1: ");
    inorder(tree1.root);
    printf("\n\n");

    processTree(&tree1);
    
    // Cây 1.2
    int a2[] = {50, 17, 9 ,14,12 ,23, 19, 76 ,54, 72, 67};
    int n2 = sizeof(a2)/sizeof(a2[0]);
    for(int i=0;i<n2;i++) {
        tree2.root = insertNode(tree2.root, a2[i]);
    }

    printf("\nCay 1.2: ");
    inorder(tree2.root);
    printf("\n\n");

    processTree(&tree2);
    
    // Cây 1.3
    int a3[] = {15, 11 ,8,6 ,9, 12, 14 ,26 ,20 ,30 ,35 };
    int n3 = sizeof(a3)/sizeof(a3[0]);
    for(int i=0;i<n3;i++) {
        tree3.root = insertNode(tree3.root, a3[i]);
    }

    printf("\nCay 1.3: ");
    inorder(tree3.root);
    printf("\n\n");

    processTree(&tree3);
    
     // Cây 1.4
    int a4[] = {3, 1, 13 ,6, 5, 10 ,11, 16, 15 ,9 ,4, 2};
    int n4 = sizeof(a4)/sizeof(a4[0]);
    for(int i=0;i<n4;i++) {
        tree4.root = insertNode(tree4.root, a4[i]);
    }

    printf("\nCay 1.4: ");
    inorder(tree4.root);
    printf("\n\n");

    processTree(&tree4);

    return 0;
}



#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

typedef struct Node {
    int data;
    struct Node* left;
    struct Node* right;
} Node;

Node* makeNode(int data) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->data = data;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

// 3.1: Tìm số lượng phần tử ít nhất từ root đến leaf
int minDepth(Node* root) {
    if(root == NULL) return 0;
    if(root->left == NULL && root->right == NULL) return 1;
    if(root->left == NULL) return 1 + minDepth(root->right);
    if(root->right == NULL) return 1 + minDepth(root->left);
    int leftDepth = minDepth(root->left);
    int rightDepth = minDepth(root->right);
    return 1 + (leftDepth < rightDepth ? leftDepth : rightDepth);
}

// 3.2: Level có số phần tử nhiều nhất
#define MAX_LEVEL 100
void countNodesPerLevel(Node* root, int level, int count[]) {
    if(root == NULL) return;
    count[level]++;
    countNodesPerLevel(root->left, level+1, count);
    countNodesPerLevel(root->right, level+1, count);
}
int maxLevel(Node* root) {
    int count[MAX_LEVEL] = {0};
    countNodesPerLevel(root, 0, count);
    int max = 0, level = 0;
    for(int i=0;i<MAX_LEVEL;i++) {
        if(count[i] > max) {
            max = count[i];
            level = i;
        }
    }
    return level; // trả về level có nhiều node nhất
}

// 3.3: Tổng giá trị các node có đúng một node con
int sumOneChild(Node* root) {
    if(root == NULL) return 0;
    int sum = 0;
    if((root->left == NULL && root->right != NULL) ||
       (root->left != NULL && root->right == NULL)) {
        sum += root->data;
    }
    sum += sumOneChild(root->left);
    sum += sumOneChild(root->right);
    return sum;
}

// 3.4: Hiệu = tổng one-child - tổng one-child bên trái
int sumOneChildLeft(Node* root) {
    if(root == NULL) return 0;
    int sum = 0;
    if(root->left != NULL && root->right == NULL) {
        sum += root->data;
    }
    sum += sumOneChildLeft(root->left);
    sum += sumOneChildLeft(root->right);
    return sum;
}

// 3.5: Node gần giá trị hiệu nhất
void findClosest(Node* root, int target, int* closest, int* minDiff) {
    if(root == NULL) return;
    int diff = abs(root->data - target);
    if(diff < *minDiff) {
        *minDiff = diff;
        *closest = root->data;
    }
    findClosest(root->left, target, closest, minDiff);
    findClosest(root->right, target, closest, minDiff);
}

int main() {
    // Ví dụ cây
    Node* root = makeNode(50);
    root->left = makeNode(17);
    root->right = makeNode(76);
    root->left->left = makeNode(9);
    root->left->right = makeNode(23);
    root->right->left = makeNode(54);
    root->right->right = makeNode(72);
    root->left->left->right = makeNode(14);
    root->left->right->right = makeNode(19);
    root->right->right->left = makeNode(67);
    root->left->left->right->left = makeNode(12);

    // 3.1
    printf("3.1: So phan tu it nhat tren duong root->leaf = %d\n", minDepth(root));

    // 3.2
    printf("3.2: Level co nhieu phan tu nhat = %d\n", maxLevel(root));

    // 3.3
    int sumOne = sumOneChild(root);
    printf("3.3: Tong gia tri cac node co 1 con = %d\n", sumOne);

    // 3.4
    int sumLeft = sumOneChildLeft(root);
    int diff = sumOne - sumLeft;
    printf("3.4: Hieu = %d\n", diff);

    // 3.5
    int closest = -1, minDiff = INT_MAX;
    findClosest(root, diff, &closest, &minDiff);
    printf("3.5: Node gan gia tri hieu nhat = %d\n", closest);

    return 0;
}

