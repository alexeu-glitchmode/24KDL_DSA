
// Bài 1
#include <stdio.h>

/* Phân tích hàm f theo quy trình 4 bước:
B1: Base case: n = 1.
B2: Kết quả của Base case: f(1) = 1.
B3: Một trường hợp ngay trước Base case  
f(2) = f(1) * 2 = 1 * 2 = 2.
B4: Một trường hợp nằm trước B3  
f(3) = f(2) * 2 = 2 * 2 = 4.
*/

// Cài đặt không đệ quy
int f(int n) {
    int result = 1;
    for (int i = 2; i <= n; i++) {
        result *= 2;
    }
    return result;
}
/*Phân tích hàm g theo quy trình 4 bước
B1: Base case: n = 1.
B2: Kết quả của Base case  
g(1) = 1.0.
B3: Một trường hợp ngay trước Base case  
g(2) = 2*2 + g(1) = 4 + 1 = 5.
B4: Một trường hợp nằm trước B3  
g(3) = 3*3 + g(2) = 9 + 5 = 14.
*/

// Cài đặt không đệ quy

float g(int n) {
    float result = 0;
    for (int i = 1; i <= n; i++) {
        result += i * i;
    }
    return result;
}


/* Phân tích hàm F theo quy trình 4 bước
B1: Base cases 
n = 0
n = 1
n = 2
B2: Kết quả của Base cases  
P(0) = 1
P(1) = 2
P(2) = 3
B3: Một trường hợp ngay trước Base case  
P(3) = P(2) * P(0) = 3 * 1 = 3.

B4: Một trường hợp nằm trước B3  
P(4) = P(3) * P(1) = 3 * 2 = 6. */

int P(int n) {
    int arr[100]; 
    arr[0] = 1;
    arr[1] = 2;
    arr[2] = 3;
    for (int i = 3; i <= n; i++) {
        arr[i] = arr[i-1] * arr[i-3];
    }
    return arr[n];
}


/* Phân tích hàm F theo quy trình 4 bước
B1: Base cases  
n = 1
n = 2
B2: Kết quả của Base cases  
F(1) = 1
F(2) = 1.
B3: Một trường hợp ngay trước Base case  
F(3) = F(2) + F(1) = 1 + 1 = 2.
B4: Một trường hợp nằm trước B3  
F(4) = F(3) + F(2) = 2 + 1 = 3. */

int F(int n) {
    if (n == 1 || n == 2) return 1;
    int a = 1, b = 1, result = 0;
    for (int i = 3; i <= n; i++) {
        result = a + b;
        a = b;
        b = result;
    }
    return result;
}

int main(){
    int n = 7;
    printf("Kết quả hàm f: %d với n = %d \n", f(n), n);
    printf("Kết quả hàm g: %d với n = %d \n", g(n), n);
    printf("Kết quả hàm F: %d với n = %d \n", F(n), n);
    printf("Kết quả hàm P: %d với n = %d \n", P(n), n);
}


//Bài 2

//Bài 2.1
#include <stdio.h>

void printArray(int arr[], int n){
    if(n==0){
        return;
    }
    printf("%d  ", arr[0]);
    printArray(arr+1, n-1);
}

int main(){
    int arr[] = {1,2,3,4,5,6,7,8,9};
    int n = 9;
    printArray(arr, n);
}

//Bài 2.2
#include <stdio.h>

int linearSearch(int arr[], int n, int value){
    if (n==0){
        return -1;
    }
    if(arr[0] == value){
        return 0;
    }
    int found = linearSearch(arr+1, n-1, value);
    if(found == -1){
        return -1;
    }
    else{
        return found +1;
    }
}

int main(){
    int arr[] = {1,2,3,4,5,6,7,8,9};
    int n = 9, value =8;
    printf("Found at Index: %d (-1 means not found)", linearSearch(arr, n, value));
}


//Bài 2
// Bài 2.3a
#include <stdio.h>
#define MAX 20

typedef struct {
    int a[MAX];
    int top;
} Stack;


void init(Stack *s){
    s->top = -1;
}

int isEmpty(Stack* s){
    return s->top == -1;
}

int isFull(Stack* s){
    return s->top == MAX - 1;
}

void push(Stack* s, int value){
    s->top++;
    s->a[s->top] = value;
}

int pop(Stack* s){
    int data = s->a[s->top];
    s->top--;
    return data;
}

void recursionStack(Stack *s){
    if(isEmpty(s)){
        return;
    }
    printf("Pop: %d\n", pop(s));
    recursionStack(s);
}

int main(){
Stack s;
init(&s);
 int arr[20] = {5, 12, -3, 7, 9, 0, 21, -8, 14, 6,
                   11, 4, -2, 18, 1, 10, -5, 13, 8, 16};

    for(int i = 0; i < 20; i++){
        push(&s, arr[i]);
    }
    recursionStack(&s);

    return 0;
}

//Bài 2.3b
// Bài 2.3b
#include <stdio.h>
#define MAX 20

typedef struct {
    int head, tail;
    int a[MAX];
} Queue;

void init(Queue* q) {
    q->head = 0;
    q->tail = -1;
}

int isEmpty(Queue *q){
    if(q->head == -1 || q->head == q->tail + 1)
        return 1;
    return 0;
}

int isFull(Queue *q){
    if (q->tail == MAX - 1)
        return 1;
    return 0;
}
void put(Queue* q, int value){
    q->tail++;
    q->a[q->tail] = value;
}
int get(Queue* q){
    int data = q->a[q->head];
    q->head++;
    return data;
}
void recursionQueue(Queue *q){
    if(isEmpty(q)){
        return;
    }
    printf("Pop: %d\n", get(q));
    recursionQueue(q);
}

int main(){
Queue q;
init(&q);
 int arr[20] = {5, 12, -3, 7, 9, 0, 21, -8, 14, 6,
                   11, 4, -2, 18, 1, 10, -5, 13, 8, 16};

    for(int i = 0; i < 20; i++){
        put(&q, arr[i]);
    }
    recursionQueue(&q);

    return 0;
}

//Bài 2.4
#include  <stdio.h>

int binarySearch(int arr[], int value, int low, int high)
{
    if (high <= low)
        return (value > arr[low]) ? (low + 1) : low;

    int mid = (low + high) / 2;

    if (value == arr[mid])
        return mid;

    if (value > arr[mid])
        return binarySearch(arr, value, mid + 1, high);
    return binarySearch(arr, value, low, mid - 1);
}

int main(){
    int arr[] = { 37, 23, 0, 17, 12, 72, 31, 46, 100, 88, 54 };
    int n = 11, value=72;
    for(int i=0; i<n; i++){
        printf("%d  ", arr[i]);
    }
    printf("\n%d  ", value);
   int index = binarySearch(arr, value, 0, n-1);
    
    printf("\nFound %d at %d",value, index );
    return 0;
}


// Bài 3


#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define MAX 20

// Cấu trúc Stack đại diện cho chiếc hộp
typedef struct {
    int data[MAX];
    int top;
} Stack;

void initStack(Stack *s) {
    s->top = -1;
}

int isFull(Stack *s) {
    return s->top == MAX - 1;
}

int isEmpty(Stack *s) {
    return s->top == -1;
}

void push(Stack *s, int value) {
    if (!isFull(s)) {
        s->data[++(s->top)] = value;
    }
}

int pop(Stack *s) {
    if (!isEmpty(s)) {
        return s->data[(s->top)--];
    }
    return 0;
}

void lamBoThe(Stack *s) {
    int value = rand() % 10 + 1;
    push(s, value);
    printf("Lam bo the so: %d vao hop.\n", value);
    if (value == 1) {
        return;
    }
    if (!isFull(s)) {
        lamBoThe(s);
    }
}

int nhungTinhTong(Stack *s) {
    if (isEmpty(s)) {
        return 0;
    }
    int currentCard = pop(s);
    printf("Nhung lay the so: %d\n", currentCard);
    
    return currentCard + nhungTinhTong(s);
}

int main() {
    srand(time(NULL));

    Stack chiecHop;
    initStack(&chiecHop);

    printf("Qua trinh Lam bo the\n");
    lamBoThe(&chiecHop);

    printf("\nQua trinh Nhung tinh tong\n");
    int tong = nhungTinhTong(&chiecHop);

    printf("\n=> Tong cac the Nhung da lay ra la: %d\n", tong);

    return 0;
}

/*Phân tích hàm lamBoThe theo quy trình 4 bước
Bước 1 (Base case): Khi số ngẫu nhiên vừa sinh ra có giá trị bằng 1 hoặc khi Stack đã đầy 20 thẻ.
Bước 2 (Kết quả Base case): Thực hiện lệnh push thẻ số 1 đó vào hộp và kết thúc hàm, không gọi thêm bất kỳ lời gọi đệ quy nào nữa.
Bước 3 (1 bước trước Base case): Sinh ra một số n != 1. Thực hiện push(n) vào hộp, sau đó gọi chính hàm lamBoThe để tìm kiếm tấm thẻ tiếp theo.
Bước 4 (Bước trước Bước 3): Tương tự bước 3, là trạng thái khi hộp đang trống hoặc đã có một vài thẻ, tiếp tục thực hiện quy trình: Sinh số -> Push vào hộp -> Kiểm tra điều kiện dừng.

*Phân tích hàm nhungTinhTong theo quy trình 4 bước
Bước 1 (Base case): Khi kiểm tra thấy Stack rỗng (isEmpty == true), nghĩa là Nhung đã lấy hết thẻ trong hộp ra.
Bước 2 (Kết quả Base case): Trả về giá trị 0. 
Bước 3 (1 bước trước Base case): Trong hộp chỉ còn lại đúng 1 tấm thẻ cuối cùn(cũng là thẻ đầu tiên Lâm bỏ vào).
+ Lấy thẻ đó ra (giả sử giá trị là x).
+ Kết quả trả về = x + nhungTinhTong(hộp rỗng) => x + 0 = x.
Bước 4 (Bước trước Bước 3): Trong hộp còn 2 tấm thẻ.
+ Lấy thẻ trên cùng ra (giả sử giá trị y).
+ Kết quả trả về = y + nhungTinhTong(hộp còn 1 thẻ) => y + x.
*/
